#!/usr/bin/python3

#
# Copyright (C) 2024 Nethesis S.r.l.
# SPDX-License-Identifier: GPL-2.0-only
#

import sys
import json
import subprocess
from euci import EUci
from nethsec import utils, firewall, ovpn
import ipaddress
import base64

## Utils

def generate_wireguard_keys():
    private_key = subprocess.run(["wg", "genkey"], capture_output=True, text=True).stdout.strip()
    public_key = subprocess.run(["wg", "pubkey"], input=private_key, capture_output=True, text=True).stdout.strip()
    return private_key, public_key

def get_wireguard_interface():
    u = EUci()
    interfaces = utils.get_all_by_type(u, "network", "interface")
    for i in interfaces:
        interface = interfaces[i]
        if interface.get("proto") == "wireguard":
            return i
    return None

def set_wireguard_interface(u, name, interface, private_key, listen_port, network, public_endpoint, routes):
    u.set("network", interface, "interface")
    u.set("network", interface, "proto", "wireguard")
    u.set("network", interface, "private_key", private_key)
    u.set("network", interface, "listen_port", listen_port)
    # calculate the first IP for network
    net = ipaddress.ip_network(network, strict=False)
    first_ip = str(list(net.hosts())[0])
    u.set("network", interface, "addresses", [first_ip])
    u.set("network", interface, "ns_network", network)
    u.set("network", interface, "ns_public_endpoint", public_endpoint)
    u.set("network", interface, "ns_routes", routes)
    u.set("network", interface, "ns_name", name)
    u.save("network")

def remove_wireguard_interface(u, interface):
    u.delete("network", interface)
    u.save("network")

def set_wireguard_peer(u, interface, account, route_all_traffic, client_to_client, ns_routes):
    peer_section = f"{interface}_{account}_peer"
    if u.get("network", peer_section, default=None) is None:
        # First time configuration
        u.set("network", peer_section, "wireguard_%s" % interface)
        private_key, public_key = generate_wireguard_keys()
        u.set("network", peer_section, "public_key", public_key)
        u.set("network", peer_section, "private_key", private_key)

        # calculate next available IP
        vpn_addr = u.get("network", interface, "ns_network")
        net = ipaddress.ip_network(vpn_addr, strict=False)
        used_ips = set()
        used_ips.add(str(list(net.hosts())[0])) # first host is reserved for the server
        for p in utils.get_all_by_type(u, "network", f"wireguard_{interface}"):
            peer_ip = u.get("network", p, "allowed_ips", default="")
            if peer_ip:
                used_ips.add(peer_ip)
        for ip in net.hosts():
            if str(ip) not in used_ips:
                ipaddr = str(ip)
                break
        if not ipaddr:
            return utils.validation_error("ipaddr", "no_available_ip", account)
        # save peer ip address to custom field, allowed_ips will be calculated later
        u.set("network", peer_section, "ns_ip", ipaddr)
        u.set("network", peer_section, "persistent_keepalive", 25)
        u.set("network", peer_section, "description", account)
        u.set("network", peer_section, "ns_link", f"wireguard/{interface}")
        # automatically create route for the peer
        u.set("network", peer_section, "route_allowed_ips", '1')

    # Update configuration
    u.set("network", peer_section, "ns_route_all_traffic", '1' if route_all_traffic else '0')
    u.set("network", peer_section, "ns_client_to_client", '1' if client_to_client else '0')
    u.set("network", peer_section, "ns_routes", ns_routes)
    # Set allowed_ips: the IP of the peer must be the first one
    allowed_ips = [u.get("network", peer_section, "ns_ip")]
    if ns_routes:
        # add all ns_routes to allowed_ip: smake sure the server can reach the peer and the newtorks behind it
        allowed_ips += ns_routes
    u.set("network", peer_section, "allowed_ips", allowed_ips)

    u.save("network")
    return {"section": peer_section}

def remove_wireguard_peer(u, interface, account):
    peer_section = f"{interface}_{account}_peer"
    u.delete("network", peer_section)
    u.save("network")

## APIs

def list_instances():
    u = EUci()
    ret = []
    interfaces = utils.get_all_by_type(u, "network", "interface")
    for i in interfaces:
        interface = interfaces[i]
        if interface.get("proto") == "wireguard":
            ret.append(i)
    return {"instances": ret}

def get_instance_defaults():
    u = EUci()
    ret = {}
    next_instance = len(list_instances()['instances']) + 1
    if next_instance == 1:
        listen_port = 51820
    else:
        listen_port = 51820 + next_instance - 1
    interface = f'wg{next_instance}'
    ret["listen_port"] = listen_port
    ret["interface"] = interface
    # search for a free network
    used_networks = []
    interfaces = utils.get_all_by_type(u, "network", "interface")
    for i in interfaces:
        interface = interfaces[i]
        if interface.get("proto") == "wireguard":
            addr = u.get("network", i, "addresses", default="")
            if addr:
                net = ipaddress.IPv4Network(addr, strict=False)
                used_networks.append(str(net))
    network = ovpn.random_network()
    while network in used_networks:
        network = ovpn.get_random_network()
    ret["network"] = network
    ret["routes"] = ovpn.get_local_networks(u)
    try:
        ret["public_endpoint"] = ovpn.get_public_addresses(u)[0]
    except:
        ret["public_endpoint"] = ""
    return ret

def set_instance(args):
    u = EUci()
    # check if the interface already exists
    if u.get("network", args['instance'], default=None) is None:
        # First time configuration
        firewall.add_service(u, f'WireGuard{args["instance"]}', args['listen_port'], ['udp'], link=f"wireguard/{args['instance']}")
        zone = f"{args['instance']}vpn"
        firewall.add_trusted_zone(u, zone, link=f"wireguard/{args['instance']}")
        firewall.add_device_to_zone(u,  args['instance'], zone)
        private_key, public_key = generate_wireguard_keys()
    else:
        private_key = u.get("network", args['instance'], "private_key")
        public_key = subprocess.run(["wg", "pubkey"], input=private_key, capture_output=True, text=True).stdout.strip()
    set_wireguard_interface(u,
                            args['name'],
                            args['instance'],
                            private_key,
                            args['listen_port'],
                            args['network'],
                            args['public_endpoint'],
                            args['routes']
    )

    return {"public_key": public_key}

def remove_instance(instance):
    u = EUci()
    remove_wireguard_interface(u, instance)
    firewall.remove_device_from_zone(u, instance, f"{instance}vpn")
    firewall.delete_linked_sections(u, f"wireguard/{instance}")
    return {"result": "success"}

def get_configuration(instance):
    u = EUci()
    ret = u.get_all("network", instance)
    ret['ns_client_to_client'] = ret.get('ns_client_to_client', '0') == '1'
    ret['ns_route_all_traffic'] = ret.get('ns_route_all_traffic', '0') == '1'
    return ret

def set_peer(args):
    u = EUci()
    ret = set_wireguard_peer(u, args["instance"], args["account"], args["route_all_traffic"], args["client_to_client"], args["ns_routes"])
    return ret

def remove_peer(args):
    u = EUci()
    interface = args["instance"]
    account = args["account"]
    remove_wireguard_peer(u, interface, account)
    return {"result": "success"}

def download_peer_config(args):
    u = EUci()
    interface = args["instance"]
    account = args["account"]
    peer_section = f"{interface}_{account}_peer"
    data = u.get_all("network", peer_section)
    private_key = data["private_key"]
    server_private_key = u.get("network", interface, "private_key")
    server_public_key = subprocess.run(["wg", "pubkey"], input=server_private_key, capture_output=True, text=True).stdout.strip()
    peer_ip = ','.join(list(data["allowed_ips"]))
    persistent_keepalive = data["persistent_keepalive"]
    server_port = u.get("network", interface, "listen_port")
    public_endpoint = u.get("network", interface, "ns_public_endpoint")
    allowed_ips = []
    # push custom routes
    try:
        routes = list(u.get_all("network", interface, "ns_routes"))
    except:
        routes = []
    if routes:
        allowed_ips += routes
 
    # force all traffic through the tunnel
    if data.get("ns_route_all_traffic", '0') == '1':
        allowed_ips.append("0.0.0.0/0")
        allowed_ips.append("::/0")
    else:
        # push route for client to client communication
        if data.get("ns_client_to_client", '0') == '1':
            allowed_ips.append(u.get("network", interface, "ns_network"))
        else:
            allowed_ips.append(u.get("network", interface, "addresses"))
    name = u.get("network", interface, "ns_name")
    config = f"""
# Account: {account} for {name}
[Interface]
PrivateKey = {private_key}
Address = {peer_ip}

[Peer]
PublicKey = {server_public_key}
AllowedIPs = {",".join(allowed_ips)}
Endpoint = {public_endpoint}:{server_port}
PersistentKeepalive = {persistent_keepalive}
    """

    qrcode = subprocess.run(["qrencode", "-t", "ANSIUTF8"], input=config, capture_output=True, text=True).stdout
    # encode qrcode in base64
    qrcode = base64.b64encode(qrcode.encode()).decode()
    return {"config": config.strip(), "qrcode": qrcode}

cmd = sys.argv[1]

if cmd == 'list':
    print(json.dumps({
        "get-configuration": {"instance": "wg1"},
        "list-instances": {},
        "set-instance":  {
            "name": "wg1",
            "instance": "wg1",
            "listen_port": 51820,
            "network": "192.168.231.0/24",
            "public_endpoint": "wg.server.org",
            "routes": ["192.168.100.0/24"]
        },
        "remove-instance": {"instance": "wg1"},
        "set-peer": {"instance": "wg1", "account": "user1", "route_all_traffic": False, "client_to_client": False, "ns_routes": []},
        "remove-peer": {"instance": "wg1", "account": "user1"},
        "download-peer-config": {"instance": "wg1", "account": "user1"}
    }))
else:
    action = sys.argv[2]

    if action == "set-peer":
        args = json.loads(sys.stdin.read())
        ret = set_peer(args)
    elif action == "remove-peer":
        args = json.loads(sys.stdin.read())
        ret = remove_peer(args)
    elif action == "remove-instance":
        args = json.loads(sys.stdin.read())
        ret = remove_instance(args["instance"])
    elif action == "get-configuration":
        args = json.loads(sys.stdin.read())
        ret = get_configuration(args["instance"])
    elif action == "download-peer-config":
        args = json.loads(sys.stdin.read())
        ret = download_peer_config(args)
    elif action == "list-instances":
        ret = list_instances()
    elif action == "set-instance":
        args = json.loads(sys.stdin.read())
        ret = set_instance(args)
    elif action == "get-instance-defaults":
        ret = get_instance_defaults()

    print(json.dumps(ret))