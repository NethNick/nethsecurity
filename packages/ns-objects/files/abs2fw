#!/usr/bin/python3

#
# Copyright (C) 2022 Nethesis S.r.l.
# SPDX-License-Identifier: GPL-2.0-only
#

import os
import sys
import json
import shutil
import filecmp
from euci import EUci
from nextsec import utils

macs = {}
tmp_dir = '/tmp/absfirewall'
tmp_file = f'/tmp/absfirewall/firewall'

def uniq(l):
    return list(set(l))

def get_macs(uci, section):
    return list(uci.get('objects', section, 'macaddr', list=True, default=[]))

def add_macs(name, new_macs, ipset):
    global macs
    for m in new_macs:
        if m not in macs:
            macs[m] = set()
        macs[m].add(ipset)

def get_addresses(uci, section):
    ipv4 = []
    ipv6 = []
    # get addresses from plain ipaddr option
    for ip in uci.get('objects', section, 'ipaddr', list=True, default=[]):
        if ':' in ip:
            ipv6.append(ip)
        else:
            ipv4.append(ip)
    # get vpn reservation
    for v in uci.get('objects', section, 'vpn', list=True, default=[]): # vpn reservation
        ip = uci.get('openvpn', v, 'ipaddr', default='')
        if not ip:
            continue
        if ':' in ip:
            ipv6.append(ip)
        else:
            ipv4.append(ip)
    # get address from DNS record and DHCP reservation
    for st in ['host', 'domain']:
        for h in uci.get('objects', section, st, list=True, default=[]): # dhcp reservation
            ip = uci.get('dhcp', h, 'ip', default='')
            if not ip:
                continue
            if ':' in ip:
                ipv6.append(ip)
            else:
                ipv4.append(ip)
 
    return (ipv4, ipv6)

def add_user_set(uci, section, family, addresses):
    name = f"us{section}.v{family[3]}"
    add_set(uci, name, family, addresses)
    return name

def add_group_set(uci, section, family, addresses):
    name = f"gs{section}.v{family[3]}"
    add_set(uci, name, family, addresses)
    return name

def add_set(uci, name, family, entries):
    section = utils.get_id(name)
    uci.set('firewall', section, 'ipset')
    uci.set('firewall', section, 'name', name)
    uci.set('firewall', section, 'match', 'src_ip')
    uci.set('firewall', section, 'family', family)
    uci.set('firewall', section, 'enabled', '1')
    uci.set('firewall', section, 'timeout', '0') # enable timeout flag
    uci.set('firewall', section, 'entry', uniq(entries))

def add_user_ipsets(uci, user):
    sets = []
    (ipv4, ipv6) = get_addresses(uci, user)
    if ipv4:
        sets.append(add_user_set(uci, user, 'ipv4', ipv4))
    if ipv6:
        sets.append(add_user_set(uci, user, 'ipv6', ipv6))

    return sets

def add_group_ipsets(uci, group):
    ipv4 = []
    ipv6 = []
    macs = []
    sets = []
    for u in uci.get('objects', group, 'user', list=True, default=[]):
        (uipv4, uipv6) = get_addresses(uci, u)
        ipv4 = ipv4 + uipv4
        ipv6 = ipv6 + uipv6
        macs = macs + get_macs(uci, u)

    if ipv4:
        sets.append(add_group_set(uci, group, 'ipv4', ipv4))
    
    if ipv6:
        sets.append(add_group_set(uci, group, 'ipv6', ipv6))

    return (macs, sets)

def output_mac2ip_config():
    global macs
    dconfig = {}
    for m in macs:
        dconfig[m] = {'v6': [], 'v4': []}
        for ipset in macs[m]:
            (name, family) = ipset.split(".")
            dconfig[m][family].append(ipset)

    print(json.dumps(dconfig))

# initialize config files
if not os.path.isfile('/etc/config/absfirewall'):
    shutil.copyfile('/etc/config/firewall', '/etc/config/absfirewall')
    # nothing to do anymore
    output_mac2ip_config()
    sys.exit(0)

# replace firewall config
if os.path.isfile('/etc/config/firewall'):
    os.makedirs(tmp_dir, exist_ok=True)
    shutil.copyfile('/etc/config/absfirewall', tmp_file)
    shutil.copyfile('/etc/config/objects', f'{tmp_dir}/objects')

uci = EUci(confdir=tmp_dir)
macs = {}
rules = []

for section in utils.get_all_by_type(uci, 'firewall', 'rule'):
    # convert user sources and destinations
    user = uci.get('firewall', section, f'user_src', default=None)
    if user:
        rule = uci.get_all('firewall', section)
        del(rule[f'user_src'])
        sets = add_user_ipsets(uci, user)
        uci.delete('firewall', section)
        for s in sets:
            crule = rule.copy()
            crule['ipset'] = s
            rules.append(crule)
            add_macs(user, get_macs(uci, user), s)
 
    # convert group sources and destinations
    group = uci.get('firewall', section, f'group_src', default=None)
    if group:
        rule = uci.get_all('firewall', section)
        del(rule[f'group_src'])
        (gmacs, sets) = add_group_ipsets(uci, group)
        uci.delete('firewall', section)
        for s in sets:
            crule = rule.copy()
            crule['ipset'] = s
            rules.append(crule)
            add_macs(group, gmacs, s)

# generate new rules with ipsets
count = 0
for rule in rules:
    section = utils.get_id(f'arule{count}')
    uci.set('firewall', section, 'rule')
    for option in rule:
        uci.set('firewall', section, option, rule[option])
    count += 1
uci.commit('firewall')

# replace original firewall file, if generated file is different
if not filecmp.cmp('/etc/config/firewall', tmp_file):
    os.unlink('/etc/config/firewall')
    shutil.copyfile(tmp_file, '/etc/config/firewall')

# remove temporary directory
if os.path.isdir(tmp_dir):
    shutil.rmtree(tmp_dir, ignore_errors=True)

# write to stdin the config for mac2ip daemon
output_mac2ip_config()
