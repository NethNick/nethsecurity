#!/usr/bin/python3

import sys
import json
import signal
import socket
import subprocess
from euci import EUci
from nextsec import firewall, utils

sock = None
macs = None
addr_socket = '/var/run/addrwatcher.sock'

def uniq(l):
    return list(set(l))

def update_mac(mac, ip):
    global macs
    if mac in macs and macs[mac]['ip'] != ip:
        macs[mac]['ip'] = ip
        for ipset in macs[mac]['ipsets']:
            cmd = ['/usr/sbin/nft', 'add', 'element', 'inet', 'fw4', ipset, "{%s timeout 60s}" % ip]
            # FIXME: do not add ipv4 to ipv6 adn viceversa
            subprocess.run(cmd)

def get_macs(uci, section):
    return list(uci.get('objects', section, 'macaddr', list=True, default=[]))

def add_user_macs(name, user_macs):
    global macs
    for m in user_macs:
        if m not in macs:
            macs[m] = {"ip": "", "ipsets": []}
        for t in ['u4s', 'u4d', 'u6s', 'u6d']:
            macs[m]["ipsets"].append(f"{t}{name}")

def add_group_macs(name, group_macs):
    global macs
    for m in group_macs:
        if m not in macs:
            macs[m] = {"ip": "", "ipsets": []}
        for t in ['g4s', 'g4d', 'g6s', 'g6d']:
            macs[m]["ipsets"].append(f"{t}{name}")

def get_addresses(uci, section):
    ipv4 = []
    ipv6 = []
    for ip in uci.get('objects', section, 'ipaddr', list=True, default=[]):
        if ':' in ip:
            ipv6.append(ip)
        else:
            ipv4.append(ip)
 
    for v in uci.get('objects', section, 'vpn', list=True, default=[]): # vpn reservation
        ip = uci.get('openvpn', v, 'ipaddr', default='')
        if not ip:
            continue
        if ':' in ip:
            ipv6.append(ip)
        else:
            ipv4.append(ip)
    for st in ['host', 'domain']:
        for h in uci.get('objects', section, st, list=True, default=[]): # dhcp reservation
            ip = uci.get('dhcp', h, 'ip', default='')
            if not ip:
                continue
            if ':' in ip:
                ipv6.append(ip)
            else:
                ipv4.append(ip)
 
    return (ipv4, ipv6)

def add_user_set(uci, section, match, family, addresses):
    fid = family[3]
    if match == 'src_ip':
        name = f"u{fid}s{section}"
    else:
        name = f"u{fid}d{section}"
    return add_set(uci, name, match, family, addresses)

def add_group_set(uci, section, match, family, addresses):
    fid = family[3]
    if match == 'src_ip':
        name = f"g{fid}s{section}"
    else:
        name = f"g{fid}d{section}"
    return add_set(uci, name, match, family, addresses)


def add_set(uci, name, match, family, entries):
    section = utils.get_id(name)
    uci.set('firewall', section, 'ipset')
    uci.set('firewall', section, 'name', name)
    uci.set('firewall', section, 'match', match)
    uci.set('firewall', section, 'family', family)
    uci.set('firewall', section, 'enabled', '1')
    uci.set('firewall', section, 'timeout', '0') # enable timeout flag
    uci.set('firewall', section, 'entry', uniq(entries))
    return section

# cleanup existing ipsets
def cleanup_ipsets(uci):
    for section in utils.get_all_by_type(uci, 'firewall', 'ipset'):
        if section[0:6] in ['ns_u4s', 'ns_u4d', 'ns_u6s', 'ns_u6d', 'ns_g4s', 'ns_g4d', 'ns_g6s', 'ns_g6d']:
            uci.delete('firewall', section)

# generate user ipset
def add_user_ipsets(uci):
    for section in utils.get_all_by_type(uci, 'objects', 'user'):
        (ipv4, ipv6) = get_addresses(uci, section)
        if ipv4:
            add_user_set(uci, section, 'src_ip', 'ipv4', ipv4)
            add_user_set(uci, section, 'dst_ip', 'ipv4', ipv4)
        if ipv6:
            add_user_set(uci, section, 'src_ip', 'ipv6', ipv6)
            add_user_set(uci, section, 'dst_ip', 'ipv6', ipv6)

        add_user_macs(section, get_macs(uci, section))

# generate group ipset
def add_group_ipsets(uci):
    for section in utils.get_all_by_type(uci, 'objects', 'group'):
        ipv4 = []
        ipv6 = []
        macs = []
        for u in uci.get('objects', section, 'user', list=True, default=[]):
            (uipv4, uipv6) = get_addresses(uci, u)
            ipv4 = ipv4 + uipv4
            ipv6 = ipv6 + uipv6
            macs = macs + get_macs(uci, u)

        if ipv4:
            add_group_set(uci, section, 'src_ip', 'ipv4', ipv4)
            add_group_set(uci, section, 'dst_ip', 'ipv4', ipv4)
    
        if ipv6:
            add_group_set(uci, section, 'src_ip', 'ipv6', ipv6)
            add_group_set(uci, section, 'dst_ip', 'ipv6', ipv6)

        add_group_macs(section, macs)

def handler(signum, frame):
    print('Signal handler called with signal', signum)
    sock.close()
    run()

def run():

    global addr_socket
    global sock
    global macs 

    uci = EUci()
    macs = {}
    cleanup_ipsets(uci)
    add_user_ipsets(uci)
    add_group_ipsets(uci)
    #firewall.apply(uci) # FIXME
    uci.commit('firewall')

    print(macs)
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.connect(addr_socket)
    fs = sock.makefile(mode='r')
    for line in fs:
        try:
            # example: 1671787799 eth0 0 52:54:00:9d:3d:e5 192.168.100.177 ARP_REQ
           (ts, interface, vlan, mac, ip, event) = line.strip().split(" ")
           update_mac(mac, ip)
        except:
            continue

signal.signal(signal.SIGUSR1, handler)
run()
