#!/usr/bin/python3

import argparse
import os
import sys
import shutil
import logging
import urllib.request
import tarfile
from nethsec import snort

# Constants
DATA_DIR = "/var/ns-snort"
RULES_DIR = os.path.join(DATA_DIR, "rules")
BACKUP_DIR = os.path.join(DATA_DIR, "old.rules")
OFFICIAL_RULES_DIR = os.path.join(DATA_DIR, "snort-rules")
ET_RULES_DIR = os.path.join(DATA_DIR, "et-rules")

COMMUNITY_RULES_URL = "https://www.snort.org/downloads/community/snort3-community-rules.tar.gz"
ET_RULES_URL = "https://rules.emergingthreats.net/open/snort-2.9.7.0/emerging.rules.tar.gz"

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(message)s')

def log(message):
    logging.info(message)

def backup_rules():
    # remove old backup
    shutil.rmtree(BACKUP_DIR, ignore_errors=True)
    if os.path.exists(RULES_DIR):
        shutil.copytree(RULES_DIR, BACKUP_DIR)
        log(f"Backup created at {BACKUP_DIR}")

def generate_testing_rules():
    log("Generating testing rules...")
    testing_rules_dir = os.path.join(DATA_DIR, "testing-rules")
    shutil.rmtree(testing_rules_dir, ignore_errors=True)
    os.makedirs(testing_rules_dir, exist_ok=True)
    rules_file = os.path.join(testing_rules_dir, "testing.rules")
    testing_rules = [
        'alert icmp any any <> any any (msg:"TEST ALERT ICMP v4"; icode:0; itype:8; sid:99010;)',
        'alert icmp any any <> any any (msg:"TEST ALERT ICMP v6"; icode:0; itype:33; sid:99011;)',
        'alert icmp any any <> any any (msg:"TEST ALERT ICMP v6"; icode:0; itype:34; sid:99012;)'
    ]
    with open(rules_file, 'w') as f:
        for rule in testing_rules:
            f.write(rule + "\n")
    log(f"Testing rules generated at {rules_file}")

def download_official_rules(oinkcode):
    if oinkcode:
        url = f"https://www.snort.org/downloads/snortrules-snapshot-{oinkcode}.tar.gz"
        archive_loc = f"snortrules-snapshot-{oinkcode}"
    else:
        log("Downloading community rules...")
        url = COMMUNITY_RULES_URL
        archive_loc = "snort3-community-rules"
    
    os.makedirs(OFFICIAL_RULES_DIR, exist_ok=True)
    archive_path = os.path.join(DATA_DIR, f"{archive_loc}.tar.gz")
    
    try:
        with urllib.request.urlopen(url) as response:
            if response.status != 200:
                log(f"Failed to download rules from {url}")
                sys.exit(1)
            with open(archive_path, 'wb') as f:
                shutil.copyfileobj(response, f)
        log(f"Downloaded rules to {archive_path}")
        
        with tarfile.open(archive_path, 'r:gz') as tar:
            tar.extractall(path=OFFICIAL_RULES_DIR)
        log(f"Extracted rules to {OFFICIAL_RULES_DIR}")
    except Exception as e:
        log(f"Failed to download rules from {url}: {e}")
        sys.exit(1)

def download_et_rules():
    url = ET_RULES_URL
    archive_loc = "emerging-threats-rules"
    archive_path = os.path.join(DATA_DIR, f"{archive_loc}.tar.gz")
    os.makedirs(ET_RULES_DIR, exist_ok=True)
    log("Downloading Emerging Threats rules...")
    try:
        with urllib.request.urlopen(url) as response:
            if response.status != 200:
                log(f"Failed to download rules from {url}")
                sys.exit(1)
            with open(archive_path, 'wb') as f:
                shutil.copyfileobj(response, f)
        log(f"Emerging Threats rules downloaded to {archive_path}")
        
        with tarfile.open(archive_path, 'r:gz') as tar:
            tar.extractall(path=ET_RULES_DIR)
        log(f"Extracted Emerging Threats rules to {ET_RULES_DIR}")
    except Exception as e:
        log(f"Failed to download Emerging Threats rules from {url}: {e}")
        sys.exit(1)

def filter_official_rules(policy, disabled_sids):
    rules = []
    ret = []
    # official rules are downloaded to /var/snort.d/snort3-community-rules/snort3-community.rules
    for rule in snort.parse_file(os.path.join(OFFICIAL_RULES_DIR, "snort3-community-rules/snort3-community.rules")):
        # rule.metadata can contain:
        # - policy balanced-ips drop
        # - policy connectivity-ips drop
        # - policy security-ips drop
        # - policy max-detect-ips drop
        if rule.metadata is None or not rule.enabled or rule.sid in disabled_sids:
            log(f"Skipping disabled rule {rule.sid}")
        if policy == "connectivity" and 'policy connectivity-ips drop' in rule.metadata:
            rules.append(rule)
        elif policy == "balanced" and 'policy balanced-ips drop' in rule.metadata:
            rules.append(rule)
        elif policy == "security" and 'policy security-ips drop' in rule.metadata:
            rules.append(rule)
    for rule in rules:
        if rule.action != 'drop':
            rule.raw = rule.raw.replace(rule.action, "drop", 1)
        ret.append(rule.raw)
    return ret

def filter_et_rules(alert, block, disabled_sids):
    rules = []
    if not alert and not block:
        log("No ET categories specified.")
        return rules
    alert_files = []
    if alert == 'default':
        alert_files = [
            'emerging-current_events',
            'emerging-dos',
            'emerging-ftp',
            'emerging-games',
            'emerging-inappropriate',
            'emerging-info',
            'emerging-misc',
            'emerging-mobile_malware',
            'emerging-p2p',
            'emerging-scan',
            'emerging-shellcode',
            'emerging-sql',
            'emerging-malware',
            'emerging-voip',
            'emerging-web_client',
            'emerging-worm'
        ]
    elif alert:
        alert_files = alert.split(',')
    block_files = []
    if block == 'default':
        block_files = [
            'emerging-botcc',
            'emerging-ciarmy',
            'emerging-compromised',
            'emerging-drop',
            'emerging-dshield',
            'emerging-activex',
            'emerging-attack_response',
            'emerging-exploit',
            'emerging-netbios'
        ]
    elif block:
        block_files = block.split(',')
    # ET rules are downloaded to /var/snort.d/emerging-threats-rules/rules/
    for file in alert_files:
        log(f"Processing alert ET category {file}")
        tmp = snort.parse_file(os.path.join(ET_RULES_DIR, "rules", f"{file}.rules"))
        for rule in tmp:
            if rule.enabled and rule.sid not in disabled_sids:
                if rule.action != 'alert':
                    rule.raw = rule.raw.replace(rule.action, "alert", 1)
            rules.append(rule.raw)
    for file in block_files:
        log(f"Processing block ET category {file}")
        tmp = snort.parse_file(os.path.join(ET_RULES_DIR, "rules", f"{file}.rules"))
        for rule in tmp:
            if rule.enabled and rule.sid not in disabled_sids:
                # replace alert with drop
                if rule.action != 'drop':
                    rule.raw = rule.raw.replace(rule.action, "drop", 1)
                rules.append(rule.raw)

    return rules

def prepare_rule_file():
    rule_file = os.path.join(RULES_DIR, "snort.rules")
    if os.path.exists(rule_file):
        os.remove(rule_file)
    return rule_file

def append_rules_to_file(rules):
    # create dir if not exists
    os.makedirs(RULES_DIR, exist_ok=True)
    rule_file = os.path.join(RULES_DIR, "snort.rules")
    # create file if not exists
    if not os.path.exists(rule_file):
        with open(rule_file, 'w') as f:
            f.write("# This file is automatically generated by ns-snort-rules\n")
    for rule in rules:
        with open(rule_file, 'a') as f:
            f.write(str(rule) + "\n")
    log(f"Appended {len(rules)} rules to {rule_file}")

def main():
    parser = argparse.ArgumentParser(description='Process snort rules.')
    parser.add_argument('--testing', action='store_true', help="Create synthetic testing rules instead of downloading.")

    # Options for official rules
    parser.add_argument('--official-download', action='store_true', help="Download official Snort rules.")
    parser.add_argument('--official-oinkcode', type=str, help="Oinkcode for downloading official rules.")
    parser.add_argument('--official-policy', choices=['connectivity', 'balanced', 'security'], help="Policy for official rules: connectivity, balanced, or security.")
    # Options for ET rules
    parser.add_argument('--et-download', action='store_true', help="Download Emerging Threats rules.")
    parser.add_argument('--et-alert', type=str, help="Comma separated list of ET categories to alert on, or 'default'.", default='')
    parser.add_argument('--et-block', type=str, help="Comma separated list of ET categories to block, or 'default'.", default='')
    parser.add_argument('--et-list', action='store_true', help="List available Emerging Threats categories.")
    # General options
    parser.add_argument('--disable-rules', type=str, help="Comma separated list of SIDs to disable.", default='')
    
    args = parser.parse_args()

    # if no args, print help
    if len(sys.argv) == 1:
        parser.print_help(sys.stderr)
        sys.exit(1)

    if args.et_list:
        log("Available Emerging Threats categories:")
        rules_dir = os.path.join(ET_RULES_DIR, "rules")
        # Check for /var/ns-snort/et-rules/rules/LICENSE
        if not os.path.exists(os.path.join(rules_dir, "LICENSE")):
            download_et_rules()
        for file in os.listdir(rules_dir):
            if file.endswith(".rules"):
                log(file[:-6])
        sys.exit(0)

    backup_rules()
    
    if args.testing:
        generate_testing_rules()
        sys.exit(0)

    prepare_rule_file() # /etc/snort/rules/snort.rules

    if args.disable_rules:
        # make a list of disabled sids as integers
        disabled_sids = list(map(int, args.disable_rules.split(',')))
    else:
        disabled_sids = []

    rules = []
    if args.official_download:
        download_official_rules(args.official_oinkcode)
        rules += filter_official_rules(args.official_policy, disabled_sids)
    if args.et_download:
        download_et_rules()
        rules += filter_et_rules(args.et_alert, args.et_block, disabled_sids)

    append_rules_to_file(rules)

if __name__ == "__main__":
    main()
